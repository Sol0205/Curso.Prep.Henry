Clases:
    //Muchas veces cuando creamos un objeto, estamos creando una plantilla. En lugar de copiar esa plantilla una y otra vez, JavaScript nos da a lo que llamamos un constructor (class). Las clases comparten la misma funcionalidad que los objetos normales, pero tambien se expande mucho en esa funcionalidad. Las clases son útiles para crear muchos objetos que comparten algunas de las mismas propiedades y métodos (como los usuarios en un sitio web).

    Class e instanciación pseudo-clásica
        //Si tienes experiencia en un lenguaje orientado a objetos (como Java o C#), probablemente estés familiarizado con el concepto de clases. Si bien JavaScript no proporciona un "verdadero" sistema de clases, hay algo muy familiar. En aras de la discusión, llamaremos a nuestros objetos de clase 'clases'. Se instancia de manera pseudo clásica, usando la palabra clave "new", y puede tomar argumentos.

        //En este ejemplo crearemos una clase Gato. La convencion para las clases consiste en dar un nombre en mayuscula al nombre de todo lo que se pueda instanciar la palabra clave new.
        //Cuando usamos la palabra clave new, JavaScript hace un gran trabajo detras de escena para nosotros y crea y devuelve un objeto automaticamente

        function Gato(nombre){
            //El nuevo operador crea un objeto, "this"
            this.nombre = nombre;
            this.maullar = function(){
                return "Mi nombre es " + this.nombre + " ... Meow!"
            }
            //Devuelve el objeto "this"
        }

        const sam = new Gato ("Sam");
        const kitty = new Gato ("Kitty");
        console.log(sam.maullar());     //"Mi nombre es Sam ... Meow!"
        console.log(kitty.maullar());   //"Mi nombre es Kitty ... Meow!"

    This en las clases

        En el ejemplo anterior lo usamos en el metodo  de los maullidos. Una buena regla general si no esta sefuro de a que se refiere this, es observar donde se llama el metodo y el objeto a la izquierda del punto. ESE ES EL OBJETO AL QUE SE REFIERE THIS.

Prototype 
    Las clases tienen una forma única de establecer un método una vez y dar acceso a cada objeto de esa clase a esos métodos. Esto se llama el prototype. Cada clase tiene una propiedad prototype, que luego podemos establecer en métodos:
    
    function Usuario(nombre, github){
        this.nombre = nombre;
        this.github = github;
    }

    Usuario.prototype.introduccion = function() {
        return  "Mi nombre es " + this.nombre + ", mi usuario de github es " + this.github + ".";
    }

    let juan = new Usuario ("Juan", "juan,perez");
    let antonio = new Usuario ("Antonio", "atralice");

    console.log(juan.introduccion());   // Mi nombre es Juan, mi usuario de Github es juan.perez.
    console.log(riley.introduccion());  // Mi nombre es Antonio, mi usuario de Github es atralice.
    Los metodos de prototype tienen acceso a la palabra clave this y, al igual que antes, siempre apuntara al objeto (a la izquierda del punto) que lo que esta llamando

    Object.create
        El metodo create de los objetos nos permite crear un objeto a partir de un prototype especificado

            // creo un objecto con un objeto vacio como proto
            > var obj = Object.create({})

            > obj
            < Object {}

            // creo que un objeto a partir de un proto de Objeto
            > var obj = Object.create(Object.prototype)
            // que es lo mismo que crear un objeto vacio literal
            > var obj = {}

    Object.assign
        El metodo assign de los objetos te permite agregar propiedades a un objeto pasado por parametro

        > var obj = {}
        
        //No hace falta guardar el resultado porque los objetos se pasan por "referencia"
        Object.assign(obj, {nombre:"Emi", apelllido:"Chequer"})
        
        > obj.nombre
        < "Emi"

Herencia Clásica.

    Un tema muy importante es la Herencia y Polimorfismo y de las clases (los vamos a llamar constructores por ahora).

    Con Herencia  nos referimos a la capacidad de un constructor de heredar propiedades y metodos de otro constructor.

    Con Polimorfismo nos referimos a la capacidad de que objetos distintos puedan responder a un llamdo igual de acuerdo a su propia naturaleza.

Herencia JavaScript.

    A diferencia de la herencia clasica, nos manejamos con prototipos que van a tomar los metodos pasados por sus "padres" mediante la Prototype Chain.

    Cuando generamos un arreglo nuevo podemos acceder a metodos como map o slice gracias a que los heredamos del objeto array que esta cinvulado en la propiedad __proto__ y es el siguiente en el Prototype Chain.

    Tambien podemos generar nuestros constructores en el cual pueda haber variantes


        > function Persona(nombre, apellido, ciudad) {
            this.nombre = nombre;
            this.apellido = apellido;
            this.ciudad = ciudad;
        }

        > Persona.prototype.saludar = function () {
            console.log("Soy "+this.nombre+" de "+this.ciudad);
        }

        > var Emi = new Persona("Emi", "Chequer", "Buenos Aires");

        > Emi.saludar()
        < "Soy Emi de Cuenos Aires"

    Ahora todo alumno de henry antes de alumno es una persona , asi que podriamos decir que un alumno  hereda las propiedades de ser persona

        > function Alumno(nombre, apellido, ciudad, curso) {
         this.nombre = nombre;
         this.apellido = apellido;
         this.ciudad = ciudad;   
         this.curso = curso
        }

    Constructores anidados

        Pero en este caso estariamos repitiendo el codigo, y si en un futuro quisieramos cambiar una propiedad tendria que hacerlo en ambos constructores. Descartamos esa opcion

        // Lo que nosotris queremos es poder reutulizar las propiedades de persona,
            
        > function Alumno(nombre, apellido, cuidad, curso) {
            
            // vamos a usar nuestro constructor Persona dentro del alumno
                
            Persona.call(this, nombre, curso, ciudad);
                
            // Vamos a necesitar el call porque queremos que las propiedades de persona, queden en bajo el objeto que va a devolver Alumno, y no uno nuevo del constructor Persona.
            // luego le paso los valores que quiero que reciba el constructor
                
            this.curso = curso;
            this.empresa = "Soy Henry"; 
        }

        > var toni = new Alumno("Toni", "Tralice", "Tucuman", "Web Full Stack")

        // Ahora si tenemos nuestra instancia creada a partir de ambos constructores
        
        > toni.curso
        < Web Full Stack

        > toni.apellido
        < Tralice

        > toni.saludar
        < Uncaught TipeError: toni.saludar is not a "function"
        // Que paso?

    Como podemos ver los metodos de Persona no fueron pasados a nuestros Alumno. Veamos un poco el porque

    El constructor del __proto__ esta ligado a Alumno y luego al Object Object de JS. Pero el metodo saludar esta en el objeto prototype de personas... y esta perfecto, asi es como deberia funcionar, las instancias acceden al __proto__ que fue vinculado por el constructor para ver que metodos tienen. Nuestro problema es que al llamar a Persona con call en vez de con el metodo new no se esta haciendo ese vinculo en el que Persona.prototype se mete en nuestro Prototype Chain,  y entonces las instancias de Allumno no tienen acceso a los metodos de Persona

    Vamos a solucionar ese problema agregaqndo al prototipolos metodos de Persona, para esto vamos a usar el metodo Object.create

        // usamos "Object.create" porque este guardaba el argumento pasado como "__proto__" del objeto a retornar
        > Alumno.prototype = Object.create(Persona.prototype)

        // si recuerdan el objeto prototype siempre tenia una propiedad constructor que hacia referencia a la funcion  en si, con la asignacion que hicimos arriba lo pisamos, por lo que deberiamos volvera arreglarlos.
        > Alumno.prototype.constructor = Alumno

        > var Franco = new Alumno ("Franco", "Etcheverri", "Montevideo", "Bootcamp")

        >Franco.saludar()
        < "Soy Franco de Montevideo"

<<<<<< Fin >>>>>>